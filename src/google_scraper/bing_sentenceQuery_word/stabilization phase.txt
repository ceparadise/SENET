Stack Exchange network consists Q A community including largest trusted online community developer learn share knowledge build career
What usually understood word stabilization
I know nanoparticles easily participate chemical reaction unite one another
And example porous structure used stabilize
But exactly prevent nanoparticles
Does mean constrain chemical reaction aggregation also allow nanoparticles move transit spacial isomer
Is common understand stabilization also conservation phase state nanoparticle
Sorry bad English
By posting answer agree
asked viewed site design logo Stack Exchange Inc user contribution licensed

concept
A distributed system end correct matter state initialized
That correct state reached finite number execution step
At first glance guarantee self stabilization may seem le promising traditional algorithm aim guarantee system always remains correct state certain kind state transition
However traditional fault tolerance always achieved
For example achieved system started incorrect state corrupted intruder
Moreover complexity hard debug analyze distributed system
Hence hard prevent distributed system reaching incorrect state
Indeed form incorporated many modern network since give ability cope fault foreseen design algorithm
Many year seminal paper concept remains important present important foundation
As result Dijkstra paper received one highest recognition distributed computing community
Moreover Dijkstra death award renamed called Dijkstra Award
presented concept prompting research area
He also presented first algorithm rely strong assumption system
Some previous protocol used practice actually stabilize assuming existence clock global system assuming known upper bound duration system transition
It ten year later pointed importance Dijkstra work researcher directed attention elegant concept
A starting arbitrary state guaranteed converge legitimate state remain legitimate set state thereafter
A state legitimate starting state algorithm satisfies specification
The property enables distributed algorithm recover regardless nature
Moreover algorithm initialized eventually start behave correctly regardless initial state
Dijkstra paper introduces concept present example context network computer ordered circle exactly one supposed hold token given time
The first detect error explicitly order subsequently repair
Instead constantly pushed system towards legitimate state
Since traditional method detecting error often difficult behavior considered desirable
The method described paper cited collect huge amount information whole network one place attempt determine whether collected global state correct even determination alone hard task
More recently researcher presented newer method error detection system using local checking
The term refers part computer network
When local detection used computer network required communicate entire network order detect error error detected computer communicate nearest neighbor
These local detection method simplified task designing algorithm considerably
This error detection mechanism recovery mechanism designed separately
Newer algorithm based detection method also turned much efficient
Moreover paper suggested rather efficient general transformer transform non self stabilizing algorithm become self stabilizing
The idea The combination part self stabilizing
Initial self stabilizing protocol also presented paper
More efficient reset protocol presented later
Additional efficiency introduced notion protocol
The idea behind small number error occurs recovery time made short
Dijkstra original algorithm property
A useful property algorithm composed layer layer exhibit
The stabilization time composition bounded sum individual stabilization time layer
The time algorithm measured asynchronous round cycle
It also interesting measure output stabilization time
For subset state variable defined externally visible
Certain state output defined correct legitimate
The set output component system said stabilized time start correct provided stay correct indefinitely unless additional fault occur
The output stabilization time time number asynchronous output stabilizes
A system A system said expected number round needed reach correct state bounded constant
Design sense well known difficult job
In fact class distributed algorithm property local checking legitimacy network state evaluated single process
The obvious case Dijkstra defined process detect whether network state legitimate case one token present process
This suggests distributed system sort component taking local action based local knowledge eventually guarantee global convergence end
To help overcome difficulty designing defined type stabilization devised
For instance property distributed system possibility reach legitimate behavior every possible state
Weak stabilization easier design guarantee convergence run distributed system rather convergence every run
A algorithm converges global state value communication register used algorithm remain fixed
An extension concept
The intent cope dynamic distributed system undergo topological change
In classical theory arbitrary change viewed error guarantee given system stabilized
With superstabilizing system predicate always satisfied system topology reconfigured

This service advanced JavaScript available learn The system locally exponentially stabilizable finite dimensional internal controller acting component system
Unable display preview
Unable display preview
Over million scientific document fingertip Springer International Publishing AG
Part

While software likely estimate stabilization phase software project perfectly spreadsheet let capture big variable stabilization phase
By We deliver top business tech news story company people product revolutionizing planet
Delivered Daily Our editor highlight TechRepublic article gallery video absolutely miss stay current latest IT news innovation tip
Delivered Fridays

obj stream r ú oûóä Õc ûð hè mð ÆlI á D Ðß ËÒ ïûcu É ÿ
NT Ç A ÿ îú QË K KN ãT
Þ æD Ù ÜF
L Q X ècÝ à Y ÓXân ùº
ÅWû Öþ ÖÏ æ
b Jb ª v L oº Ä EIþï jnúO jy ýgx oaMçÃ Â endobj obj endobj obj stream Q TªJ
æ çà XN ÚÒ Î ÏSò æ Ñe â víg AëH l q YÉÊÍø þñfßf dÌøøîJ ÎªTÔÌÙ Ö ÿéw ÞrÝõ þDY NÏh q NØbr E õ ÌjéÏb
ÛqC
üö Èì P Íèv GÑ ºË ÿGtY GlÈ çÝ W ïémÌ YJÏ àËNº Å j ÍRÏK ÜT Y ÇBrrlÝl Ò
Èª á X
w r ù endobj obj endobj obj stream l

É ÙbôãS cÏwè î ÌW lw ÔTÉ ÏÛ
ÀIôÉ ä ôLCU PuãË L À I R ÕF E ÈUÛÏÍ ê vêÚ v Æ úþ e
ê çð qóï ýAÕduP ÕÙRð Kuðd Gä MQ K V XÒïa B Ã ºMpÍû xW W ç b L ýÂ Ó Q ÐÌøëqY ÝY ÙªYºóú â xg ãÝW Ý ñ j
endobj obj endobj obj stream gVÚ ã é v á onq
ETrAv ïhMÞiOO Ø aiÀ ê Á M è ÉÝ æqèºæø ri Z à E Y KÀÄí úêqÉ

hÏO
Q Ã ÜcVöc Ç Ífæ O Ç nèiëNõÃÃØ v ö xMÆ kpË P oy z Ú çRtª Q nÝ Å endobj obj endobj obj stream Éï IÎûåY A
u JOo ÜÇzú ú qª é ÅØ Ýk ÆµÅTÀ tZ Ý nõc v Ñ E È Rm DáB ß Â Äð
Rá Ñ ç Ç ÍhÞ
dà b ÕP

Some dev organization use stabilization phase way improve quality
But case harm good
About five year ago I cancer scare
A routine blood test led additional test eventually led prognosis I could fatal form cancer
After spinal tap waiting longest week life I found I cancer
To say I relieved complete understatement
Cancer simplest definition unregulated cell growth invades nearby part body
In word reason cancer feed sustain
During career I many development project stabilization phase end
The stabilization phase period time team focus fixing bug addressing debt
Debt work must completed ship done part sprint
Bugs common form debt
Other example could include meeting localization performance accessibility requirement
More extreme example include ensuring product installs user upgrade prior version
These stabilization phase felt like fighting cancer
An unregulated growth bug debt invaded part product process team
The organization went intensive stabilization phase eradicate bug
Chemotherapy often used eradicate cancer undesirable side effect worst killing healthy cell
The stabilization phase also undesirable side effect attacking team morale feeding quality product dulling learning ability
The truth I discovered year stabilization phase treatment disease cure
Rather stabilization phase disease
It awful organism feeding organization
In article I reveal stabilization phase thing must eradicated
The stabilization phase ultimate prophesy
If dedicate certain amount time end development cycle address debt debt grow fill
This became clear three year ago
Our organization switching Agile methodology practicing sprint goal done done end every sprint
However six sprint planned stabilization phase case
During time would feature work focus would ensure product ready ship
In Sprint one team trying extremely hard keep bug debt low
They fixed bug starting new feature
They ensured new feature met accessibility security localization performance requirement end every sprint
However team consequently team productivity looked lower
Someone management sent investigate
After long discussion virtue carrying debt management person said Look two sprint add feature door closed
Therefore fixing bug would irresponsible two month fix bug stabilization
Now time add feature
Later time fix bug
This person stupid
This person long history shipping software
And think logic irrefutable
The person problem stabilization phase
The fact stabilization phase existed changed way development organization worked stabilization phase became necessity
Just like cancer stabilization phase want exist
On face stabilization phase appears commitment quality
It provides adequate time ensure quality product high
This honorable goal
However I stated existence stabilization phase encourages team save bug phase
And longer take fix bug cost fix
I many many meeting closed bug without fixing enough time fix end stabilization
Many bug would simple fix addressed earlier
The stabilization phase also provides illusion productivity development phase
It feel great implementing new feature one without regard debt piling
Of course feature actually complete achievement real real financing car ca afford celebrating
If organization depends stabilization phase removing make sense aggressively yanking large tumor
Doing cause damage good
The organization must reduce dependency stabilization phase slowly starving thing life
In previous example organization went Agile kept stabilization phase
That stabilization phase new feature restriction led bad behavior
Our organization went six sprint followed another stabilization phase
However time team could prove addressed debt could add new feature time
That made huge difference
Teams wanted rely stabilization phase still could team committed completing feature addressing debt early rewarded ability add new functionality
Some team started stabilization initiative goal making stabilization phase different sprint
The stabilization phase slowly became le le necessary never really died
It shrink however reducing affect healthy dev organization around
At beginning article I talked relieved I find I cancer
However every three month I go blood test every year I get full body scan
I rest life
My doctor vigilant sign cancer
Eliminating reducing dependency stabilization phase I would consider get healthy program dev organization
After stay healthy program begin
As body staying healthy requires discipline hard work
Our organization found old habit die hard easy slip back unhealthy behavior
Investigating work done stabilization phase like blood test body scan dev organization
It provides insight indicator something unhealthy
Like doctor dev organization must extremely vigilant
Any work done stabilization phase symptom something potentially unhealthy diligently followed
We found team stabilization free would sometimes go back depending
Investigating happens help organization stay healthy
I say use stabilization phase unhealthy
That feel little dogmatic
However I strongly believe organization methodically reduce dependency stabilization phase become healthier productive result
Maybe ca cancer free reduce threatening benign tumor
About Author Gregg Boer Principal Program Manager Microsoft year experience software
Over career Gregg worked Project Manager Program Manager Requirements Lead Software Engineer Analyst QA Lead Software Designer
Gregg joined Microsoft believed vision Team Foundation Server
Currently Gregg working team developing set Agile Tools built top TFS Platform
Sign newsletter
I agree site

Link back

A transforms computer code written one source language another programming language target language
Compilers type support digital device primarily computer
The name primarily used program translate create program
However many different type compiler
If compiled program run computer whose different one compiler run compiler
A written language compiled
A program translates higher level one
A program translates language usually called transpiler
A language usually program translates form expression without change language
The term refers tool used create parser perform syntax analysis
A compiler likely perform many following operation conversion input program
Compilers implement operation phase promote efficient design correct transformation source input target output
Program fault caused incorrect compiler behavior difficult track work around therefore compiler implementers invest significant effort ensure
Compilers translator used transform source program
An computer software transforms executes indicated operation
The translation process influence design computer language lead preference compilation interpretation
In practice interpreter implemented compiled language compiler implemented interpreted language
Theoretical computing concept developed scientist mathematician engineer formed basis digital computing development World War II
Primitive binary language evolved digital device understand one zero circuit pattern underlying machine architecture
In late forty assembly language created offer workable abstraction computer architecture
Limited capacity early computer led substantial technical challenge first compiler designed
Therefore compilation process needed divided several small program
The front end program produce analysis product used back end program generate target code
As computer technology provided resource compiler design could align better compilation process
The human mind design better solution language move machine higher level
So development language follows naturally capability offered digital computer
language strictly defined syntax semantics form language architecture
Elements formal language include The sentence language may defined set rule called grammar
BNF describes syntax sentence language used syntax Algol
The idea derive concept linguist
BNF extension become standard tool describing syntax programming notation many case part compiler generated automatically BNF description
In designed algorithmic programming language called Plan Calculus
While actual implementation occurred presented concept later seen designed Ken Iverson late
APL language mathematical computation
language design formative year digital computing provided useful programming tool variety application Compiler technology evolved need strictly defined transformation source program target target program digital computer
The compiler could viewed front end deal analysis source code back end synthesize analysis target code
Optimization front end back end could produce efficient target code
Some early milestone development compiler technology Early operating system system software written assembly language
In early language system programming still controversial due resource limitation
Still several research industry effort began shift toward system programming language example
Basic Combined Programming Language designed University Cambridge originally developed compiler writing tool
Several compiler implemented Richards book provides insight language compiler
BCPL influential system programming language still used research also provided basis design B C language
Basic Language Implementation System Software developed Digital Equipment Corporation DEC computer
Wulf Carnegie Mellon University CMU research team
The CMU team went develop compiler one year later
Multiplexed Information Computing Service operating system project involved later led MIT
Multics written language developed IBM IBM User Group
IBM goal satisfy business scientific system programming requirement
There language could considered offered complete solution even though implemented
For first year Mulitics project subset language could compiled assembly language Early EPL compiler Doug McIlory Bob Morris Bell Labs
EPL supported project compiler full could developed
Bell Labs left Multics project Over time hope replaced frustration group effort initially failed produce economically useful system
Continued participation would drive project support cost
So researcher turned development effort
A system programming language based BCPL concept written
Ritchie created compiler B wrote Uniplexed Information Computing Service operating system Unics eventually became spelled Unix
Bell Labs started development expansion based B BCPL
The BCPL compiler transported Multics Bell Labs BCPL preferred language Bell Labs
Initially program Bell Labs B compiler used C compiler developed
In new provided resource define extension B rewrite compiler
By design C language essentially complete Unix kernel rewritten Steve Johnson started development Portable C Compiler PCC support retargeting C compiler new machine
OOP offered interesting possibility application development maintenance
OOP concept go back part language science
At Bell Labs development became interested OOP
first used system programming
The initial design leveraged C language system programming capability Simula concept
facility added
The Cfront program implemented language compiler
In subsequent year several compiler developed popularity grew
In many application domain idea using language quickly caught
Because expanding functionality supported newer increasing complexity computer architecture compiler became complex
Defense Advanced Research Projects Agency sponsored compiler project Wulf CMU research team
The Production Quality design would produce Production Quality Compiler PQC formal definition source language target
PQCC tried extend term beyond traditional meaning parser generator without much success
PQCC might properly referred compiler generator
PQCC research code generation process sought build truly automatic system
The effort discovered designed phase structure PQC
The compiler provided initial structure
The phase included analysis front end intermediate translation virtual machine middle end translation target back end
TCOL developed PQCC research handle language specific construct intermediate representation
Variations TCOL supported various language
The PQCC project investigated technique automated compiler construction
The design concept proved useful optimizing compiler compiler programming language
The Ada Stoneman Document formalized program support environment APSE along kernel KAPSE minimal MAPSE
An Ada interpreter supported development standardization effort American National Standards Institute ANSI International Standards Organization ISO
Initial Ada compiler development Military Services included compiler complete integrated design environment along line Stoneman Document
Army Navy worked Ada Language System ALS project targeted architecture Air Force started Ada Integrated Environment AIE targeted IBM series
While project provide desired result contribute overal effort Ada development
Other Ada compiler effort got way Britain University York Germany University Karlsruhe
In Verdix later acquired Rational delivered Verdix Ada Development System VADS Army
VADS provided set development tool including compiler
could hosted variety Unix platform DEC Ultrix Sun Solaris targeted Motorola Army CECOM evaluation
There soon many Ada compiler available passed Ada Validation test
The Freesoftware Foundation GNU project developed GCC provides core capability support multiple language target
The Ada version one widely used Ada compiler
GNAT free also commercial support example AdaCore founded provide commercial software solution Ada
GNAT Pro includes GNU GCC based GNAT tool suite provide
language continued drive compiler research development
Focus area included optimization automatic code generation
Trends programming language development environment influenced compiler technology
More compiler became included language distribution PERL Java Development Kit component IDE VADS Eclipse Ada Pro
The interrelationship interdependence technology grew
The advent web service promoted growth web language scripting language
Scripts trace back early day Command Line Interfaces CLI user could enter command executed system
User Shell concept developed language write shell program
Early Windows design offered simple batch programming capability
The conventional transformation language used interpreter
While widely used Bash Batch compiler written
More recently sophisticated interpreted language became part developer tool kit
Modern scripting language include PHP Python Ruby Lua
Lua widely used game development
All interpreter compiler support
When field compiling began late focus limited translation language program machine code
The compiler field increasingly intertwined discipline including computer architecture programming language formal method software engineering computer security
The Compiler Research The Next Years article noted importance language Java
Security parallel computing cited among future research target
A compiler implement formal transformation source program target program
Compiler design define end end solution tackle defined subset interface compilation tool
preprocessors assembler linkers
Design requirement include rigorously defined interface internally compiler component externally supporting toolsets
In early day approach taken compiler design directly affected complexity computer language processed experience person designing resource available
Resource limitation led need pas source code
A compiler relatively simple language written one person might single monolithic piece software
However source language grows complexity design may split number interdependent phase
Separate phase provide design improvement focus development function compilation process
Classifying compiler number pass background hardware resource limitation computer
Compiling involves performing lot work early computer enough memory contain one program work
So compiler split smaller program made pas source representation performing required analysis translation
The ability compile classically seen benefit simplifies job writing compiler compiler generally perform compilation faster
Thus partly driven resource limitation early system many early language specifically designed could compiled single pas
In case design language feature may require compiler perform one pas source
For instance consider declaration appearing line source affect translation statement appearing line
In case first pas need gather information declaration appearing statement affect actual translation happening subsequent pas
The disadvantage compiling single pas possible perform many sophisticated needed generate high quality code
It difficult count exactly many pass optimizing compiler make
For instance different phase optimization may analyse one expression many time analyse another expression
Splitting compiler small program technique used researcher interested producing provably correct compiler
Proving correctness set small program often requires le effort proving correctness larger single equivalent program
Regardless exact number phase compiler design phase assigned one three stage
The stage include front end middle end back end
This approach make possible combine front end different language back end different sharing optimization middle end
Practical example approach multiple shared optimization multiple
The front end analyzes source code build internal representation program called IR
It also manages data structure mapping symbol source code associated information location type scope
While frontend single monolithic function program commonly implemented analyzed several phase may execute sequentially concurrently
This method favored due modularity
Most commonly today frontend broken three phase also known lexing also known scanning parsing
Lexing parsing comprise syntactic analysis word syntax phrase syntax respectively simple case module lexer parser automatically generated grammar language though complex case require manual modification
The lexical grammar phrase grammar usually simplifies analysis significantly handled semantic analysis phase
The semantic analysis phase generally complex written hand partially fully automated using
These phase broken lexing scanning evaluating parsing building CST parse tree transforming AST syntax tree
In case additional phase used notably rare
The main phase front end include following The middle end performs optimization intermediate representation order improve performance quality produced machine code
The middle end contains optimization independent CPU architecture targeted
The main phase middle end include following Compiler analysis prerequisite compiler optimization tightly work together
For example crucial
The scope compiler analysis optimization vary greatly small level even whole program
Obviously compiler potentially better job using broader view
But broad view free large scope analysis optimization costly term compilation time memory space especially true interprocedural analysis optimization
Interprocedural analysis optimization common modern commercial compiler
The open source criticized long time lacking powerful interprocedural optimization changing respect
Another open source compiler full analysis optimization infrastructure used many organization research commercial purpose
Due extra time space needed compiler analysis optimization compiler skip default
Users use compilation option explicitly tell compiler optimization enabled
The back end responsible CPU architecture specific optimization The main phase back end include following branch software engineering deal trying show compiler behaves according
Techniques include developing compiler using using rigorous testing often called compiler validation existing compiler
programming language usually appear type mind either designed
However practice rarely anything language exclusively compiled exclusively interpreted although possible design language rely run time
The categorization usually reflects popular widespread implementation language instance sometimes called interpreted language C compiled one despite existence BASIC compiler C interpreter
Interpretation replace compilation completely
It hide user make gradual
Even though interpreter interpreted directly executed program needed somewhere bottom stack see
Further compiler contain interpreter optimization reason
For example expression executed compilation result inserted output program prevents recalculated time program run greatly speed final program
Modern trend toward time blur traditional categorization compiler interpreter even
Some language specification spell implementation include compilation facility example
However nothing inherent definition Common Lisp stop interpreted
Other language feature easy implement interpreter make writing compiler much harder example many scripting language allow program construct arbitrary source code runtime regular string operation execute code passing special
To implement feature compiled language program must usually shipped includes version compiler
One classification compiler generated code executes
This known A compiler one output intended directly run type computer operating system compiler run
The output designed run different platform
Cross compiler often used developing software intended support software development environment
The output compiler produce code VM may may executed platform compiler produced
For reason compiler usually classified native cross compiler
The lower level language target compiler may
C often viewed sort portable assembler also target language compiler

original compiler used C target language
The C created compiler usually intended read maintained human
So pretty C intermediate code irrelevant
Some feature C turn good target language

C code directive generated support original source
While common compiler type output machine code many type Compiler construction taught university school part curriculum
Such course usually supplemented implementation compiler
A example compiler Wirth used teach compiler construction
In spite simplicity compiler introduced several influential concept field including us programming language mature time lead need Standardization
The American National Standards Institute ANSI International Organization Standardization ISO manage standard various programming language FORTRAN COBOL C
Universities conjunction industry government provide active research development programming language associated language tool compiler integrated development environment formal validation suite
Professional organization representation across research education industry government
These include Institute Electrical Electronic Engineers IEEE Association Computing Machinery ACM
A number conference field present advance compiler construction one main topic
support number conference including The European Joint Conferences Theory Practice Software sponsor International Conference Compiler Construction paper academic industrial sector
Asian Symposium Programming Languages Systems APLAS organized Asian Association Foundation Software AAFS

