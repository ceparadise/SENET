In asserted said algorithm correct respect
correctness refers behaviour algorithm input produce expected output
A distinction made requires answer returned correct additionally requires algorithm terminates
Since general solution total correctness assertion may lie much deeper
A type play critical role total correctness algorithm depends termination
For example successively searching see find example odd quite easy write partially correct program using long division two check perfect
But say program totally correct would assert something
A proof would mathematical proof assuming algorithm specification given formally
In particular expected correctness assertion given program implementing algorithm given machine
That would involve consideration limitation
A state proof functional correctness corresponds certain program
Converting proof way called
specific reasoning rigorously correctness computer program
It us axiomatic technique define programming language semantics argue correctness program assertion known Hoare triple
Software testing activity aimed evaluating attribute capability program system determining meet required result
Although crucial software quality widely deployed programmer tester software testing still remains art due limited understanding principle software
The difficulty software testing stem complexity software completely test program moderate complexity
Testing debugging
The purpose testing quality assurance verification validation reliability estimation
Testing used generic metric well
Correctness testing reliability testing two major area testing
Software testing budget time quality

Stack Exchange network consists Q A community including largest trusted online community developer learn share knowledge build career
Using Hoare logic prove following program partially correct I know terminates n output l n x
The invariant I thinking k x
Unfortunately I know derive l n x fact loop terminated k n
I also thought adding x invariant true terminating execution false one
So question invariant
By posting answer agree
asked viewed site design logo Stack Exchange Inc user contribution licensed

Stack Exchange network consists Q A community including largest trusted online community developer learn share knowledge build career
In Section Transaction Histories A H set transaction consists two part event E reflects operation read write abort commit transaction version order committed object version
The author give comment partial order event Page For convenience present history event example consistent partial order
Furthermore wherever possible example make total order consistent event database system
Why present partial order event total order
Because partial order may imply multiple total order consistent one choose
Does choice matter later definition theorem
Some comment total version order Page follows The version order history H different order write commit event H
This flexibility needed allow certain optimistic implementation possible version placed version version order even though installed committed state installed
And The system chooses version order object
What mean database system choose version order
And
Is
concern Question theoretical result state partial order S extended total order S contains S
This result known Order Extension Principle proof result us Axiom Choice I aware whether alternative proof use
The paper written French find proof
When Adya state chooses order event best guess assumes implementation database case every history H corresponds execution database event totally ordered order order
More specifically requiring partial order history H extended total order Adya imposes whenever H instant time event take place execution database lead H le instant time take place
Choosing order event extend partial order history H needed one want prove correctness abstract specification
set property history satisfy respect given specification
Let turn Question case seems Adya want stress fact allows implementation database access version object precedes version order latest version installed
In practice choosing earlier version object could either result database able access version
lost update anomaly causal consistency user explicitly requesting access older version object
accessing older version revision SVN repository
Hope help Andrea Cerone
Edward Szpilrajn sur de partiel By posting answer agree
asked viewed active site design logo Stack Exchange Inc user contribution licensed

âãÏÓ obj endobj obj stream P n f â n

Stack Exchange network consists Q A community including largest trusted online community developer learn share knowledge build career
If familiar program verification likely prefer reading
If familiar program verification may still able answer question likely prefer reading first
It often stated checking partial correctness undecidable
For sake discussion let pick one particular way making statement precise style Floyd Hoare
A digraph distinguished node reachable
A flowgraph whose node command
There three type command assumption assertion assignment v
Here fol logic formula fol term variable
We say program way annotate node precondition postcondition precondition initial node valid hold command implies valid edge
Here Hoare triple defined follows Here argument checking partial correctness undecidable Once fill need check fol formula valid undecidable
A typical way encode termination partial correctness add special assertion essentially say since last time I executed progress towards termination
These must placed infinite walk flowgraph start initial node contain infinitely many progress assertion
To specific let say progress assertion always form positive integer preceded assignment followed assignment
Here current value former value
Now since talk positive integer compare need ensure bit fol available Let say available
I feel strongly choice
Feel free disregard convenient
Of course may use function constant mentioned program
Note adding assumption beginning program equivalent introducing axiom
Now program progress assertion still partially correct know original program terminates
Given terminating program feel coming variant function progress assertion hard
But hard
I know even huge background I still left question sort depending want look
To put differently I looking reference formalizes problem reducing termination partial correctness say something complexity
An answer would course welcome
One way answer consider computational complexity decision problem class partial correctness termination query known decidable
Abstract interpretation using polyhedral domain infer partial correctness annotation mention case required annotation conjunction linear inequality
Computing abstract exponential number variable
Then overhead finding fixed point
See Cousot early paper Apron library want play directly
Finding variant function decidable variant function linear
I could find complete characterization complexity Termination Linear Programs Tiwari section discus complexity
See also A Complete Method Synthesis Linear Ranking Functions Podelski Rybalchenko
Also Byron Cook done work leveraging abstract interpretation help construct termination argument
See example Ranking Abstractions Variance Analyses Invariance Analyses
These may give insight relationship partial correctness termination
Links There obvious reduction partial correctness namely never terminates started initial state satisfying iff false valid
I aware another
Its advantage shorter
There standard technology usually undecidable course populating graph namely form predicate transformer semantics give weakest precondition either satisfaction specification
This essentially complete theory partial correctness language indeed full correctness It chalk cheese deciding termination partial correctness hard work lie since badly undecidable
But partial correctness tangled language design issue program specification language whilst difficulty termination clean sort theory used proving termination algorithm terminate connot proven terminate relative theory
For example computation must terminate Peano arithmetic prove
My impression work pioneered Patrick Cousot dynamic area I pretend expert
By posting answer agree
asked viewed active site design logo Stack Exchange Inc user contribution licensed

Stack Exchange network consists Q A community including largest trusted online community developer learn share knowledge build career
I interested proving program may may terminate give correct answer terminates
Given I like show wherever terminates give correct answer
This seems intuitively obvious
However I struggling find appropriate math
Most importantly instead program
For example Q multivariable function Q f n general equal Q g n even defined
However think Q function program get use f g oracle
What proper way show mathematically
Or even simpler What correct mathematical term Q
If function
By I mean algorithm make use algorithm I referring particular language implementation
Note even functional language like Haskell due Halting Problem program truly function program guaranteed terminate whereas concept terminating apply function
A function f depend whether f terminates program us f subroutine
Indeed essence waht I struggling What appropriate mathematical formalism program us program subroutine
I attempt write answer Neel fewer technicality therefore really correct
By way using strange terminology I avoid
For type T appearing programming language define partial order follows integer define p int q mean p terminates q terminates evaluate integer value
function type A B define p A B q mean x A p x q x
Caveat think I called function type anything use word function
I using standard terminology type thing accept A return B called function type
Observe f int int g mean f n terminates g n f n g n expressed saying f subset g probably someone baked set theory long time ago harm
Now matter fact reasonable programming language every p A B namely x p x p
When look monotonicity mean P int int int get notion looking f int int g either P f undefined P f P g defined equal
If like know look domain theory concept properly developed
If I read correctly intuition mind go like Suppose program P take function argument
Further suppose two function f g f terminates subset input g terminates agrees g whenever terminate
Now g partially correct want argue f must also partially correct
After thing P functional parameter apply call use oracle f must compute value g possibly terminating le often
This le exactly intuition underlying
The idea interpret computation particular type CPPOs pointed partial order
That CPPO triple X X set element denoting computation nonterminating computation partial order representing close fully defined computation
least element partial order condition say countable chain chain least upper bound N
Programs interpreted continuous function CPPOs idea continuity computability
That function f X Y monotone function preserve lubs
In particular set continuous function X Y also form CPPO least element given order given pointwise f X Y g x x x Then property want follows le instantaneously
Suppose continuous P X Y Z
Then f le defined g amount saying f g
Then continuity P follows f g
Samson Abramsky Achim Jung
By posting answer agree
asked viewed active site design logo Stack Exchange Inc user contribution licensed

interesting Professor Gernot Heiser John Lions Chair Computer Science School Computer Science Engineering senior principal researcher NICTA said first time team able prove mathematical rigour code heart computer per cent therefore immune crash failure
Do expect practical time soon Verifying mathematically proving correctness line computer code project taking average six people five year
That line code verified per
Both Linux Windows something like million line code verifying would take assuming increased complexity resulting increased complexity
Clearly efficiency improvement required
Tags Comments Technically proven
Part proving program correctness picking property code prove
If overlooked even trying prove important property code could still unforseen problem
However great accomplishment
They proved free certain class bug knew look presumably cover common failure mode
What I like know many bug kernel source found corrected process proving correctness
An entire Linux distribution may amount million LOC easily broken separate program component proper softare designed
Then program component could verified one one starting important upon software depends
Clearly need build computer program mathematically prove correctness computer program
Then simply need mathematically prove correctness
Yup secure property defined proven
Furthermore large math project often contain error Do surprised closer scrutiny someone find fault proof
Because Halting problem termination program written turing complete language provable
And OS recover possible hardware failure
THAT SAID If core OS proven many strong property
ca crash reasonable hardware assumption building complex well tested
OS proven core could profitable
So congrats team let see build work
My experience testing I ahve seen large code producing vendor go standard case test
In year nobody thinking testing buffer overflow
So method scale address currently unknown
Reminds guy producing ant tackle malicious code
They already different ant stop
Suddenly ant network spend year proove code bug free
lest forget Viper chip proven correct yes practically almost useless
Also I ca help roll classic Knuth quote Note I tested code I merely proven correct
This page answer question people ask In particular We mentioned formal proof functional correctness implies absence whole class common programming error
Provided assumption true common error Buffer overflow Null pointer dereferences Pointer error general Memory leak Arithmetic overflow exception Apparently impossible
Well proof ca error though could error formulation theorem unlikely axiom
That true general case
It trivial prove termination many program
I would guess possible implement computable algorithm always terminates manner proven terminate
Crap
First third paragraph quote
Even simplest program immune defect
In one simplest program patched
One tale I heard first patch every issued program line assembly instruction
JRR I sure possible given work Alan Turing et
al
JRR Agreed
See writing Michael Mahoney historian computing Princeton engineering mathematical theory computing science
From Science The Search Mathematical Theory Efforts bring mathematical rigor programming quickly reach level complexity make technique verification subject concern prompted development science remains amalgam mathematical theory engineering practice craft skill
The best way think proving program correct mean match design
If design flawed program equally flawed still correct since match spec
Furthermore How many bug found
We found bug C code total
found testing internal student project running kernel C verification started earnest
bug found C verification phase
Because Halting problem termination program written turing complete language provable
No impossible write program given second program input determine whether second program terminate
It however entirely possible prove individual program terminate
It also worth noting proof certain correctness property C code
The assembly language code involved proved correct translation loading C code assumed correct
This impressive achievement relatively limited result show formal code verification difficult
My personal experience formal correctness proof possible prove small thing correct useful I proven something correct error tend really stupid kind easy find fix
In real world per cent NOT mean immune crash failure
JP No impossible write program given second program input determine whether second program terminate
It however entirely possible prove individual program terminate
A proof equivalent writing program
So say correctly possible write program determine termination program class program including class program proof belongs
The would belong class program fully implement Principia Mathematica would unGodelizable set program
Now basically isomorphic Godelizable one programming idea latter formal system idea
So talking program unable interpret language even written one
So go beyond simply proving subset property program instead prove given program general program would pretty simple one one short incapable modifying general
Most kernel computer system general pretty damn useless could
Of course way around fact real computer finite memory
So could iterate state program determine program property
So trivially show brute force approach exists subset program actually run given real computer since real computer actually Turing complete
JP It however entirely possible prove individual program terminate
How going prove
You would write Turing machine take program input prof whether halt
So ca prove given program terminate
code heart computer per cent therefore immune crash failure
We fired microprocessor
It got soft error caused nasty little cosmic ray
More lead shielding required
Elsewhere huge stride made wrt
efficiency given lot research going software
In CompCert project proving line compiler large subset C took Xavier Leroy year
So ca prove given program terminate
To clear given single specific program may possible prove terminates
In word write program given another program input output terminates terminate determine
Where cost
If translation code logical specification vice versa sunk
But prover cycle Moore law helping
No need go Turing Machine case
The key word individual
The point Turing Machines subtle one refers general case
A single program proven correct manually within small size
You look unassisted proof quicksort terminates
For larger program need machine help
The general technique come set theorem prove true manually construct proof term theorem
This may poor analogy technique vaguely similar applying functional decomposition standard programming problem
You quickly hit point need machine checking make kind proof manageable smart guy leave unreasonable assumption unchecked
Because Halting problem termination program written turing complete language provable
I prove program terminates int main int argc char return assemby instruction set returncode zero return calling program
really nothing function place holder IBM operating system file allocation within MVS JCL script good example benchmark case
halting problem write universal program UP determine ANY given inout program P halt
The key UP work ALL input program clearly many program small large shown terminate
There presentation given ICFP last month
Searching Experience Report Formally Verifying Microkernel bring sort link paper related research video available
For followed detail proof quite lot work
They proved line C code proof line code
Note proving certain property code opposed testing Dikjstra famously said show presence error absence something many programmer limited way long time whole point type system
Languages like Java unfortunately rather lame type system let prove much often prove much use far powerful system fact least part system like Isabelle used prove OS kernel provide
Paul say I prove program terminates int main int argc char return Sure I prove hello world program terminates well unless I put line end
But algorithm proving arbitrary program terminates
Of proving termination proving bug mathematically proving correctness line computer code
And I want know proven
It sound like proven code allow several class fault occur
Note sound like syntax correct I run gcc I get approximating I wanted
Then inevitable tradeoff preventing type error thing computer programmed using OS
I know throwing question ex animo Well proof ca error Not strictly true since could error checking code including operating system run error design hardware run
Bootstrapping entire verified system design simple enough reliably verify manually would truely huge task
Early history described There implementation comparable revision history
I quite interested formal software proof I know ever become practical exercise
For example simple program statement already unique state true false across statement
So already task correctly verifying simplest program become huge
Does matter whether prove Windows
We already proven
The real world respect mathematical proof nature Alan Braggins Thanks link
Ahhhh memory
I hope end tear like RSRE VIPER formally specified microprocessor
Because Halting problem termination program written turing complete language provable
Incorrect
It mean correct procedure try prove whether program halt must give answer halt halt ca determined
Optimizing compiler solve halting problem sense time
Great framework like
It would interesting team build new OS using framework went
Say smart phone OS
But microprocessor code would obviously fundamental
To answer recurring misconception comment yes NICTA work protect u bug specification
Do usual human method testing code review make u safe bug specification
At least class bug happen
unlikely bug found proof proof
Bugs found interface
specification axiom
Again code review protect u flawed assumption reasoning human involved process
At least hypothesis written examine
program proved terminate
program proved definition bug
This one
This contradict Computability principle least
Heck even us proved limited still trivial definition bug see tutorial To migrate toward look RTCA
level
Bruce microkernel
Most Linux would go userspace
Unless claim everything text editor formally verified going great deal practical effect
If curious attempt make low level language allow easy verification proof
Nzruss Interestingly Airbus used comparable method satisfy objective level A code
Sorry link French world embedded code published information English ERTS similar venue Bruce mention line code verified per ratio
An interesting question much cost obtain confidence piece code say level A code using test code review
Apparently since problem formal method come ahead Airbus use formal method ideology
They use think get competitive advantage way
The halting problem universal Turing machine
No thing ever built within known law physic thing buildable
Computers finite state machine assuming talking computer true random number generator
It easy prove finite state machine halt
Keep running writing state enters either hit halt state case clearly halt b hit state seen case halt ever
Of course actually possible number state far large
But mathematically possible
Part point microkernels small
Proving microkernel correct like proving initialization interrupt handler message passing system Linux OS correct
Actual paper check october ACM quasi official one cite A simple question ponder Do I care OS provably bug free provided mechanisum recognises error exception handel sensible way
As noted nothing life perfect still manage get thing done ECC work wonder unreliable communication
Another thing assume argument sake kernel sufficiently robust going se security hypervisor
Termination certainly proven many program however operating system kernel necessarily need terminate
Actually totally verified yet
All C code several hundred line ARM assembler
One next phase correspondence proof ARM assembler technology used cell phone OK Labs
It likely integrated already excellent product
Clive care
None system protect private key prevent disabling firewall etc
I posted many time MILS architecture kernel isolates critical apps main system
It currently paravirtualized Linux microvisors allow one use driver partition
The small TCB formal proof provide extreme confidence
Want see security hypervisor
It separation kernel useful enough situation
It IS hypervisor Linux apps
It run ARM
If want get started download play
It used many cell phone right
They gradually transforming core offered separate product
Personally I excited I anxiously await separation kernel high assurance middleware
It seems people like comment Halting Problem many citing Turing Machines despite fact obviously read Turing work
Perhaps would find earlier work carried Church easier understand
The work Church Turing rely solely mathematical proof
No mention made computational automaton
I wish people work IT would stick IT pretend computer scientist
Rick D might want read On Computable Numbers application Entscheidungsproblem probably Turing famous paper one defines known Turing machine
The first section called Computing Machines You download entire paper Impossibly Stupid name pretty much right
The Pentium FDIV bug present Intel starting using formal verification processor fact bug caused start formal verification
I simply ca believe many people thread keep flogging dead horse
Five different people saying mistaken bullshit halting problem twice many people correcting
Several people pointing possibility bug proof verifier even though extremely unlikely
It like one read first ten comment
Anthony DeRobertis It seems symmetric
Mathematically ca necessarily predict Turing machine mathematical construct halt
Practically ca necessarily predict practical computer halt
Have proof verifier proved correct sure proof correct
If entitled suspect verifier might buggy
would guess possible implement computable algorithm always terminates manner proven terminate
Certainly program terminates program output provably terminates I think mean
I write computable algorithm testing Goldbach Conjecture either always terminate
My guess I amass enough unproven conjecture sheer chance I likely got one terminates
You going able solve determining algorithm terminate
David Have proof verifier proved correct sure proof correct
If entitled suspect verifier might buggy
And might well say What hardware proof run buggy
Then output suspect
My response easier check error one verifier check error multitudinous program
The link posted Tim I repost obviously many read Read address many critique
David The first line recent post show important issue
The issue proving prover largely solved
When proving one go sound prover
Those like Isabelle core easily verified sound logic
It make result believable
Quite honestly building core based formal logic probably best
Now onto issue I one guy actually read comment many paper like Guttman formal method screwed
Many MANY case
The issue david mention responsible problematic proof
Proofs machine checked wrong
The system must modeled accurately right amount granularity
Issues prover like inability represent infinity must properly accounted
In process creating intermediate proof one must abstract away important property
It tough still real standard methodology
Everyone constantly inventing new tool new logic new approach using different programming language etc
All nonsense halting problem stuff aside surprised skepticism comment
I mean mathemeticians screwing simple proof phenomenon year
This line proof complex system using brand new model Haskell While NICTA UNSW renown quality I big fan even I would like see VERY thorough independent review big as proof
Is complexity enemy security
Where code review proof
Or even code released
I would guess possible implement computable algorithm always terminates manner proven terminate
By definition algorithm terminate
That one property
See TAoCP Vol page algorithm always terminate
By conjecture algorithm computable
So let rewrite I would guess possible implement algorithm way proven terminate
The correspondence connects proof correctness implementation pretty deep surprising way
If prove algorithm compile proof got executable code
So right yes I sure trying say
It seems pretty tautological
Have proof verifier proved correct sure proof correct
If entitled suspect verifier might buggy
The thing way computer written lot abstraction boundary bug lot le likely within boundary
Your program rarely produce wrong output compiler bug though unknown even rarely produce wrong output kernel bug
Bugs compiler kernel tend make program crash
The way proof verifier written including one used small amount code required trusted correct
All rest code simply manipulates interface exposed reliable core bug allow incorrect proof
Since core general simple bug would tend show rather frequently mechanism
So simply using proof engine lot thoroughly test core
Of course proof
But extremely confident
Even proof still could trust proof absolutely would changing expectation bug significant difference practical purpose
Nothing world certain
Do know certain Perelman proof Poincare conjecture correct
It seems likely small chance mistake caught anyone reviewing proof
Do know absolutely certainly infinite number prime
The proof followed grade school student absolutely sure
I think thing make u sure proof consistent mathematics part fabric coherent theory make u sure lesser still great extent reliability proof checker
I write computable algorithm testing Goldbach Conjecture either always terminate
I anticipated objection
Perhaps I said algorithm
proved always terminate program implement algorithm proved terminate
Which actually sound impressive I think
Proving program testing GC terminate would subsume GC
Hmm
I think must way make statement stronger I ca think
Nick surprised skepticism comment
Not really
I guess I pretty much agree comment
I guess I making limited point Isabelle rather verification project
Am enjoying discourse
A suggested topic next week old favourite Come From statement By definition algorithm terminate
OK I confused
You saying algorithm terminates disproves Goldbach conjecture algorithm unless disprove Goldbach conjecture
If thing algorithm call
Surely program best word
By algorithm terminates disproves GC I mean one test even number sequentially find one decompose two prime course
terminal end extremity terminate bring end terminal So I guess mean real algorithm unless run real terminal
He hardcore
Dave Walker Your comment misleading
I read VIPER paper
For one formally verified
The author dedicate entire conclusion saying proof partial mainly correspondence proof
Second look feature actually useful
It different another technology fall politics market force
If want practical processor formal method look recent VAMP MIPS family
running separation kernel stuff
VAMP might allow u easily port RTOS many supporting MIPS
Also VAMP support mode think interrupt
What need formally verified hardware assisted OS IO virtualization least IOMMU
Then I would trust binary blob
Your explanation trust sound provers like HOL excellent
This line reasoning hardware proof effort aimed microcode specific unit
In case core work right rest easy build
Modularity increase overall complexity reduces difficulty verification kind
Each component proven independently interaction modeled prove overall system
This partially high assurance moving separation kernel
More rigorous math verified processor verified IOMMU verified RTOS medium assurance good middleware networking USB Java etc
stack maybe
modular apps designed take advantage perhaps SPARKS Ada
simpler formal proof interaction system I could trust Fortunately exists today
It properly integrated
Anyone know would realize challenge I think reward worth
At least u value security safety privacy
Your explanation trust sound provers like HOL excellent
Aww thanks
At least u value security safety privacy
Hmm
I wondering would go proving privacy
With thing like facebook datamining attack Bruce wrote seems like would challenge several order magnitude difficult proving absence buffer overrun null pointer dereferencing
What attack model account
Physical access
Direct hard drive platter access
Do assume access data prove absence way infer private data
Would possible design unkeyloggable keyboard
I sure
I wonder exist yet
You saying algorithm terminates disproves Goldbach conjecture algorithm unless disprove Goldbach conjecture
If thing algorithm call
Surely program best word
A sequence instruction terminates property input hold true usually called semialgorithm
There computer science formalism define semialgorithm specifically large call problem semialgorithms
It would challenging accomplish privacy general
As suspected I thinking specific attack model protecting private key encryption key
truecrypt defeat keyloggers prevent screen spoofing assumed feature MLS security anonymous web traffic network black box via effective firewall separation private communication internet
These problem I trying solve design
Many others working solved
I specific one
You mentioned unkeyloggable keyboard
I think want trusted path
Many hardware attack main idea prevent remote access software attack right
Thanks microkernels separation kernel achieved
A basic design component user application VM usually Linux GUI screen renderer mouse keyboard graphic driver
Only GUI system access driver must go
The communication policy trusted separation kernel
ca overridden ensures security scheme
The GUI low complexity bug give input focus label window source known app control screen spoofing prevention
Many OS sort trusted path BAE System STOP OS excellent design btw Sun Trusted Solaris
Their OS big though ca proven secure
The first good trusted path imho Nitpicker GUI Dresden
It run medium assurance microkernel
They use Nizza architecture prevent keylogging spoofing
Google NICTA see many awesome practical scheme
Green Hill INTEGRITY Workstation also thing way
How would work practice
I mean could attacker hack main VM disguise malicious message get key
No
Dresden give example digital signature ecommerce
Most functionality would untrusted vm
You order total
It would send critical shopping data small trusted signing app separate partition running right microkernel
You use trusted path switch app enter password decrypt signing key visually verify signing sign signature sent back untrusted side
The secure kernel handle transfer MMU isolates process
I password manager scheme work similarly protecting master password letting password I choose
I hope example show high assurance separation kernel important
Using one decompose structure app right maintain confidentiality integrity availability
In eSign app strong assurance confidentiality esp
private key zeroized use
In password manager reduced risk
If firewall sits dedicated partition VM networking stack viral infection hack VM ca disable firewall
The us MILS architecture many great actually simple enough people understand
I post email link MILS usable high assurance request
Here whats relevant current discussion
TU Dresden OS Research Demo Family Page look Perseus uSINA Hypercell commercial Many hardware attack main idea prevent remote access software attack right
Well preventing software attack certainly important I mind smart keyboard would set sort SSL tunnel computer encrypt output hardware logger would ineffective
I sure cheaply could done perhaps would special purpose encryption chip would feasible
Of course little verification
Interesting comment though
So
Interesting academic sort way without lot practical consequence
The issue proved code conforms specification
There second step missing Proving specification describes secure kernel
This currently beyond human machine would need artificial intelligence work incredible powerful
There exists keyboard like describe
The point attack become keyboard circuitry software driver decryption
Hacking OS may compromise driver software exploit defeating hardware security
An alternative scheme would dedicated PCI card keyboard Master Slave situation
Keyboard card hardcoded key pair PCI card sends random session key boot decrypts character stream sending OS
Most scheme vulnerable power line tempest hardware attack
As far keyboard video mouse security I trust Type product
And entirely
Gweihir In case actually read research commenting prove specification describes secure kernel
They defined secure guaranteeing isolation component running top kernel communication happening kernel controlled mechanism
It called MILS architecture
They formulated Haskell Isabelle wrote executable specification Haskell Isabelle connected two wrote code connected spec Isabelle model C code
Far suggested focus beginning clearly formally defining software achieved goal
For better understanding relates security look MILS architecture Separation Kernel Protection Profile
Those security model
All prove property able write program inherit level security via careful integration
The best example system secure precisely mathematically defined proof Separation Kernel awarded Common Criteria rating Robustness evaluation
This involved checking architecture formally proving spec met requirement SAIC strong argument code consistent spec extensive NSA
In word one model security mean particular piece software
We need magical AI computer esoteric math
Or philosophically skeptical view whether ever truly prove anything
We need precise practical definition security exactly high assurance developer used
Of course prove program halt mean write program determines program halt
I pretty deep water I understand due isomorphism
constructive type theory
every formal proof corresponds computer program
However halting problem say program provably halting input proved halt
Does imply provably halting program ca proved halt using Isabelle proof checker others using Coq HOL
Duuude
I glad mentioned looking integer overflow I remember Nick P In word one model security mean particular piece software
We need magical AI computer esoteric math
Or philosophically skeptical view whether ever truly prove anything
We need precise practical definition security exactly high assurance developer used
Sadly need precise practical definition security
We need dynamic frame work think known knowns known unknown unknown knowns unknown unknown
Due unfortunatly away home moment due health reason access Internet little limited I chance go specification used supporting information
However I would surprised considered side channel great detail especially susceptance attack little currently public domain although I banging many year
The simple fact secure system fighting last war actively looking passivly oddity might might new war prelude one What needed secure framework user module within hardware software need designed securely optimaly
That user module effectivly jailed frame work resourses access strictly controled framework guidence security hyporvisor driven security rule system tough bit
The framework hyporvisor designed anomaly detected limited stoped untill security rule system certifies anomalous behaviour
Yes mean framework hardware software system
As part framework savant required freeze copy current state user module communication automaticaly without sandbox becoming aware monitoring progress yup seemingly difficult problem
We starting see early stage framework however one I looked appear recognise side channel meaningfull way
I would hazzard said blog page OS discussion would capable forming one part user module augmented provide part framework
As I noted earlier possible secure system certainly via security ECC system constrain go limite potential bandwidth side channel etc attacker ordinary user The real issue security currently efficiency bang buck long performance specmanship marketing tool choice system probably never secure first time team able prove mathematical rigour code heart computer per cent therefore immune crash failure
This done probably somewhere half dozen dozen time
It rare several project come mind top head Blacker GEMSOS Cainware much I heard bad development others name even public
Of course context normally operating hardware still assume everything deal daily basis
I sure I comment reading first bit enough I get fact
I mind smart keyboard would set sort SSL tunnel computer encrypt output hardware logger would ineffective
That would easy enough actually usefull day
The problem end run around security measure put place
All security access object physical informational
In essence access form communication Shannon reasonably good model point point communication path
However ignored problem end point assuming attack model
Unfortunatly secured unless part secure communication path With IO device like keyboard point secure path end point becomes vulnerable plain text snooping microphone camera etc etc
If think sound finger pressing key one number attack point easily defend unless keyboard secure environment TEMPEST etc
Likewise end communication path get keypress information application turn application normally give feedback key pressed
An attacker intercept plain text application unless app take keyboard cipher text directly application via feedback path
Then another problem secure comms path lack entropy
Unless keyboard encryption take account issue result simple substitution cipher key pressed Hey ho life never easy come security even simplest thing Hmm
I wondering would go proving privacy
If think falling scale zero privacy full privacy end point relativly easy prove term access
However except end point full access I think
Partial privacy controled disclosure altogether complex problem
Not primary access control also continuing access control preventing duplication disclosure entity given primary access third party use anything autherised use
In essence flip side DRM The problem end run around security measure put place
Right I mean deny
It necessarily mean SSL keyboard would worth
Then another problem secure comms path lack entropy Would actually problem actual SSL tunnel
I thought encryption used pretty good
Of course would big danger proprietary programmer could crack protocol whose purpose give flimsy cover marketing claim
Like USB key security Bruce blogged
Clive Robinson No doubt need architecture like tried failed
Probably far market force fight progress unless OEM sign
I trying say MILS architecture perfect incredibly useful easy developer understand past year ton RTOS virtualization scheme middleware appeared
In word perfect dynamic security scheme MILS best holdover many problem
As side channel I almost sure covered
The separation kernel software hardware security
The kernel address covert channel fixed processor allocation scheme
That unrealistic
In
design I use fixed space partitioning dynamic time
Covert side channel still issue
Read Clive post
He basically said I said gave specific threat
Take camera threat particular seriously
You beat keylogger install color wireless microcamera
I done I rank amateur
Many physical attack
Your better using transparent keyboard computer physically examining use ur worried
That I stake high
Section It would appear repeat
Systems like GEMSOS aim requirement design must correspond formally design code
The proof chain stop get code argument testing used instead
That actually worse BSD many eye year experience ironing bug
Additionally result product never made public peer review code bug
This first time level verification performed operating system source released
Next verify assembler
You right hardware assumption
Fortunately separation kernel need minimal hardware
Mainly CPU MMU Northbridge RAM
The rest crap OS still fine useless
It service layered top like device driver file system need reliable hardware
The cool thing MILS TCB partition different necessary kernel mode included
So even hardware assumption still high assurance kernel
When coupled quality hardware high availability solution hardware assumption even safe bet
Clive Robinson Btw sorry hear health
Seems like going
Best wish recovery
Nick P In word perfect dynamic security scheme MILS best holdover many problem
I remembered conversation befor talking IO security I like MILS many reason say perfect I doubt anything ever However one nice feature modular would quite comfortably sort framework I discussing
The downside apart side channel quite go far enough seperating application security
My somewhat quaint view framework unix small tool big job pipeline philosophy would extended
Such tool could written without security consideration
Application development would split three logical part User interface application specific logic extended OS functionality
That User interface carry going way web development application logic way gen scripting tool like DB engine mainline back end service become part OS interface
Oh business Error Checking Corrrection ECC system
It inefficient care NASA like use voting system reliability
What people voiced I hope thought applying philosophy security
That three different team build application logic using different scripting language run parrelel three system agree done
If differ problem specification implementation either security risk need resolved
The important issue security probably always moving target
Even security practitioner difficulty keeping expect jobbing programers even remotly get close
Therfore remove security asspects away let get good let security proffesionals get good
Splitting thing way I suggested framework currently best way I think
However ther one proviso pesky programmer pull sock regard error exception handeling code cutter sadly deficient currently A modularised development must proper exception handeling system work effectivly
It would provide major improvment security fault tolerant system general another beef another day Would actually problem actual SSL tunnel
I thought encryption used pretty good
It improving perfect hey I people learn experiance One issue encryption system low entropy effectivly becomes code book encryption
If key matter many bit key block cipher end substitution
However simple incorect way deal either use stream cipher simple chaining block cipher
Both problem synchronisation authentication various reason security fault
There way Do remember problem WEP
There subtalties get best u trouble
Oh traffic flow analysis deal add whole host problem ontop thing
And publicaly known problem
On top side covert channel issue
One hardware manufacture using spread spectrum techneiques beat EMC mask rather reduce eminating
A knowledgable attacker know spreading sequence used despread get original signal back
This sort advantage attacker enables pull one device hiding amongst many Then little EmSec trick like using low level RF carrier illuminate target device get cross modulated thing going inside target
Oh suceptance attack I absolutly sure hear lot future
They form fault injection attack inject energy target via form carrier power supply RF sound etc
You modulate carrier chosen attack waveform
Surprisingly form attack work way deep hardware logic thus geting past clocking input output method limiting side covert channel
If find correct waveform method syncing theoreticaly practicaly possible alter internal logic state predictable way causing software make incorect branch etc And trick follow I think well So see security concious friend like vault work Clive Robinson However I would surprised considered side channel great detail especially susceptance attack little currently public domain although I banging many year
Since I find anything except blog I search susceptance attack I guess little public domain
What susceptance attack mind saying
Clive Yes discussion
And separating interface code part
Fortunately MILS specifically designed
The idea certify one module module depend module depend
It like chaining bunch black box together like wanted let developer focus job security
This contrast unevaluatable monolithic approach
Personally I think side channel attack big issue
I know I draw heat easy attack facing average user malware spoofing phishing botnets DDOS
MILS certified middleware used defeat threat
And worried emanation security I suggested stay move laptop
Pull battery put system safe use
I recently toying way secure BIOS bootcode
That issue must resolved imho
What Clive describes usually referred TEMPEST side channel attack emanation security EMSEC
On unofficial web site information usually clumped together one name
Clive using proper terminology yet another reason expect insider
We onto Clive P If want information start resource
From limited understanding susceptance attack mean RF wave injected device wire certain way
Then measurement made resulting RF activity
Attackers analyze result see information leaked
This effect accidental
Cell phone constantly emanate EM wave mixed device cause leak confidential information
As example cell phone one particular allowed within secure telephone cellular transmission caused STU circuitry leak secret key RF radiation
The manual I read said someone cellphone talking walked near considered compromised
Injection attack powerful
Note I think attack actually codeword TEAPOT rather TEMPEST
Search word like TEAPOT NONSTOP combined word like TEMPEST emanation etc
Better result
Sadly I seem lost EMSEC bookmark restores ago
Good news I remember site info
Just dig much like
Complete Unofficial TEMPEST page best starting place Note Is currently
Check Wayback Machine
Archive possible
Best info source
Books I Looking Into Getting To Improve EMSEC Clive think
Architectural Electromagnetic Shielding Handbook Hemming Design Shielded Enclosures Gnecco Certified TEMPEST Professional Some Declassified TEMPEST Docs An example TEMPEST product NSA List Level Certified Products I shop Note If use NoScript hit allow
Allow run script machine risk hehe Google Books Injection Probe Example Thunderbird Nick P If machine purely electronic electromechanical even mechanical put nicely controled RF field working cause field modulated working
This way work metal anything dielectric constant sufficiently different surround wood plastic effect frequency You used idea interferance EM field instance Offset Radar recently millimetric body scanner
You also get effect drive road bridge etc VHF station flutter
Oh course eye see reflection transmission although eye designed see phase modulation fairly insensitive amplitude modulation couple Hz center visual field
A clasic visable effect looking moonlight lightly disturbed water sea lake see light twinkle light wave add subtract comming phase different path length
Now think funny looking helix cowles ontop foul air pipe wind cause spin process cause presure drop pipe
When new often quite shiny turning slowly acuratly tell speed rotation either reflection transmission light That get usefull information simple mechanical system observing surounding EM field One thing going hear effect wind turbine TV picture start putting house What le commonly known although obvious basic physic lesson current wire also modulates EM field around
When used EmSec TEMPEST engineer refer effect cross modulation generally considered real pain deal EMC testing
Also real pain due mechanical vibration thing coil physical tuned circuit slot cavity even antenas
However used EmSec TEMPEST variety name Nick P mentioned
However although using EM energy source remember mechanical source sound directed target effectivly passive attack
That usually effect target equipment A suceptance attack however used inject fault target equipment
That use energy source high enough level effect way equipment work
This work kind amplifier classic example leaving GSM cell phone near audio amplifier properly screened
You hear envolope digital transmission speaker sort rasping noise
Now apreciate digital electronics still analog electronics lot gain An example CMOS logic old series inverter NOT NAND NOR XOR connect resistor output back input
It act analog amplifier
In early day trick used sort clever trick engineer mainly fallen wayside place commonly see XTAL oscilators
It even work TTL gate series
If wire Schmitt inverter XTAL osc running capacitivly couple audio signal input fractionaly change bias point gate input result signal get sufficiently phase modulated third harmonic clearly heard FM radio
And thus use low power FM transmitter bug design one using exactly trick published early electronics magazine around Now imagine happens low power VHF transmitter PCB properly screened
It unknown back microprocessor system fail security guard etc fired two way radio around computer room
Or VDU one else remember screen break show odd charecters
If read Clifford Stoll book tracking german cracker mention line noise simulating jangaling key across terminal break block
It worked back call EMC real anoying problem holding back electronics industry
That digital circuit susceptable interferance energy field proper step taken
Now imagine important item security equipment True Random Number Generator TRNG
What would happen say subjected EM field
Well read couple researcher Cambridge Labs UK recently presented paper show entropy went
With simple attack
Now imagine using number different EM frequency could target diferent part circuit due track length issue
And EM field either pulse phase modulated appropriate pattern
It would directly injecting signal onto input gate TTL FM bug
That could inject fault signal chosing various part black box system wish attack
Now make realy usefull imagine listening different EM signal could get information could use syncronise fault injection waveform
You potentialy way effect operation device want attack make want And yes attack work I found way effect Mondex electronic wallet hand held gambaling game would advantage I dishonest back
Now cat officialy bag far accademics concerned Cambridge Labs paper I expect whole bunch researcher jumping onto
That said I tell Ross Anderson many year ago trying find way around DPA using unsyncronised logic
If want know hunt around injection locking thing colour sub carrier syncronisation PLL threahold extension carrier resyncronisation data coms various form Spread Spectrum system
Ian Hickman Wireless World wrote couple articals injection locking practical experiment
Also look parametric amplifier see another exploitable effect
The important thing remember EM field used susceptance attack end run around EMC TEMPEST EmSec bandwidth limiting filter Now need get computer chip proven work correctly run
Oh wait
I reminded one include link Cambridge Labs bod paper etc
So interested follow link Pragmatist Actually
I mentioned post
You build simpler chip see easier COTS vendor get right
In addition partially fully verified design VIPER VAMP
You could also take open like OpenRISC SPARC reimplement using high assurance methodology extreme testing
In word nearly bug free processor possible
The market seem want
Only market even consider satisfied ARM chip good manufacturer
Unless want get one aforementioned design run high quality ASIC FPGA settle typical processor
Clive Robinson I appreciate reply
Since I software design Cambrige research particularly interesting
I checking cambrige week ago
I know I missed
Thanks tip
Information EMSEC particularly hard come
One must solidly grasp many technical concept related EMF put piece together public
Those access readable information public
You never cease amaze knowledge subject
It lead believe well know going
Funny thing I actually keep copy post make future reference
I mainly software system guy I recently trying branch secure hardware
Do know good book subject
Something somewhat technical EE major could understand use add least little EMSEC design
If seen liked Amazon whatnot I love read
Nick P Information EMSEC particularly hard come It note lot information EmSec format
However may well change soon thanks Russia effectively mandating TEMPEST type requirments general use system sure quicker learning Russian awaiting english translation EmSec TEMPEST engineering subject practical method driven complexity
Not theoretical idea also due interaction component involved
Thus tends rule driven design likewise certification rule generaly suffer kill good reason ie large amount safety margin
Actual testing look like witch craft essence quite simple
Basicaly black box system number port energy transported
The trick identify th port energy
The important thing remember energy go must come maybe different form For instance simple device loud speaker electrical energy sound E field H field heat etc coming emission
But loud speaker like transducer two way device sound energy produce electrical energy suceptance
Unfortunatly method transporting energy inefficient transmission loss indirectly tell transducer right
The trick EmSec ensuring energy coming form carrying information would use others
Ultimately energy end back ground heat closed system due entropy moving organised disorganised state
Without going detail back ground heat also noise physical item act transducer convert heat equivalent thermal noise vice versa
Thus given temprature certain degree background thermal noise
Now information implies signal signal certain charecteristics
One bandwidth another energy importantly transmission medium carry
If limit one three sufficiently information going anywhere energy
The first idea TEMPEST reduce energy information signal back ground thermal noise also called noise floor
Thermal noise however signal right therefor bandwidth consideration thus wider bandwidth thermal noise energy actually many independent signal average go RMS
Thus given bandwidth would expect average thermal noise level
Which Hz bandwidth sometimes see quoted come
The usuall way limiting bandwidth filter
However engineer think filter actually
By limiting bandwidth excess energy go somewhere filter made reactive component net result get reflected back towards source
One problem reflected energy without proper precaution end common ground equipment
The important weasle word common mean energy get back part black box content via common path Therefor better use type filter contain non reactive component disipate reflected energy heat
Such filter also need designed limit ingres energy preferably divert away suitable disapating component
However physical component dimension side effect making reactive component radiate pick energy
Thus component cross couple energy bypass filtering component get one independent isolated circuit another
To prevent physical partition placed component desirable charecteristics reduce type energy coupled component component
Often designer concentrate one cross coupling effect forget know others
Thus rule thumb develop one cable seperation red green red black cable plaintext circuit cipher text circuit
Obviously rule thumb significant effect resource required make equipment
However two general rule apply time Reduce energy
Reduce bandwidth
A lot aspect EmSec found practical guide Electromagnetic Compatability EMC
However warned low resource EMC solution make EmSec problem considerably worse
One trick realise EMC limit mask wide band EMC problem signal narrow bandwidth spread spectrum techneiques used widen signal bandwidth thus lower level get mask
This techneique although effective get EMC mask resolving EmSec issue radiated energy
It still radiated thus deconvolving receiver remove effect spreading get original signal back
But worse process syncronus EmSec target mean help reduce non corelated signal
Thus lifting target artificialy generated noise similar equipment
Thus making single tree deep within clearly visable outside forest though standing grassy knowl
There lot lot EmSec knowing fundementals practical view point take lot rule thumb
Another good source information ARRL RSGB guide equipment design construction antenna amature radio enthusiast
However say first step along pathway
Early TEMPEST consider side channel time based attack
There story tape based OTP system unfortunatly hold release timing problem relay XOR function
Thus possible see bit flipped thus get plain text back
This apparently gave rise notion using additional relay output
The modern computer idea different reason pipelining
Thus another rule Clock input output
Which limit effect timing jitter
As get see rule start get feeling two thing working Complexity
Efficiency
Both give rise majority side channel see comercial equipment
And key managment effective design methodology
Which usually boil modularity module one one job effectivly segregated others via effective framework
As say EmSec ai rocket science whilst forgeting add rider easy comparison Just another way saying software free bug also outdated For generally interested Program Proof may wish track detail Tokeneer project
This formally specified Z I believe written SPARK Ada proven Ada level compliant specification free specific class error
There link
There also seems awful lot misdirection proving program termination
Those interested high assurance program typically avoid construct analyze
For usefully large set program possible analyze assure complete required Have look
There still issue around use method proof providing useful practical mean engineering software
haha assuming increased complexity increased complexity gave great smile chuckle morning cup joe thanks post
Prove program segment z correct respect initial assertion final assertion THIS IS MY QUESTION PLEASE SOLVE IT AND REPLY IMMEDIATELY URL em cite strong b sub sup ul ol li blockquote pre Photo Bruce Schneier Per Ervland
Schneier Security personal website
Opinions expressed necessarily
I writing security issue since monthly since
I write
Currently I Chief Technology Officer fellow Harvard board member

